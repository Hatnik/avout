<h1>Introducing Avout: Distributed-State in Clojure</h1>

<p>Today we are releasing <a href="http://avout.io">Avout</a>, which brings Clojure's in-memory model of <a href="http://clojure.org/state">state</a> to distributed application development by providing a distributed implementation of Clojure's <a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion Concurrency Control</a> (MVCC) <a href="http://en.wikipedia.org/wiki/Software_transactional_memory">STM</a> along with distributable and extendable versions of Clojure's <a href="http://clojure.org/atoms">Atom</a> and <a href="http://clojure.org/refs">Ref</a> concurrency primitives.</p>

<p>Avout grew from work on <a href="https://github.com/liebke/zookeeper-clj">zookeeper-clj</a>, a Clojure DSL for working with <a href="http://zookeeper.apache.org/">Apache ZooKeeper</a>. The functionality provided by ZooKeeper has proven important when building distributed applications at <a href="http://thinkrelevance.com">Relevance</a>, so zookeeper-clj was developed to ease future development with it. And with the DSL developed, it was natural to implement several common <a href="http://zookeeper.apache.org/doc/trunk/recipes.html">ZooKeeper recipes</a>, including leader-election and distributed locks, as a standalone Clojure library.</p>

<p>It was during a <a href="http://clojure.com">Clojure/core</a> Friday stand-up meeting, when I was describing the work on distributed locks, that Rich Hickey strongly suggested not stopping there, but continuing forward by implementing distributed versions of Clojure's <a href="http://clojure.org/atoms">Atom</a> and <a href="http://clojure.org/refs">Ref</a> concurrency primitives, which of course would mean implementing a distributed version of Clojure's MVCC STM. How hard could that be?! :)</p>

<p><a href="http://stuartsierra.com/">Stuart Sierra</a> and I had discussed this idea a year earlier, but we knew that we would need an implementation of distributed locks just to get started, and so never moved forward with the idea. But now I had distributed locks, some time to dedicate to the task, thanks to <a href="http://thinkrelevance.com">Relevance</a> and <a href="http://clojure.com">Clojure/core</a>, and Rich's encouragement to pursue the idea, so I did.</p>

<p>Several weeks later, after digging into the design of Clojure's STM, consulting with Rich, gathering feedback from others at Relevance and at the <a href="http://clojure-conj.org/">Conj</a>, and performing a lot of testing and tuning, <a href="http://avout.io">Avout</a> was born.</p>

<p>Avout enables techniques that require synchronous, coordinated management of distributed state (see also <a href="http://java.sun.com/developer/technicalArticles/tools/JavaSpaces/">JavaSpaces</a>), complementing approaches that focus on asynchronous, uncoordinated communication between distributed components, e.g. message queues (<a href="http://www.zeromq.org/">0MQ</a>, <a href="http://www.rabbitmq.com/">RabbitMQ</a>, <a href="http://www.jboss.org/hornetq">HornetQ</a>), event-driven approaches (<a href="http://www.jboss.org/netty">Netty</a>, <a href="https://github.com/ztellman/aleph">Aleph</a>), and actors (<a href="http://www.erlang.org/">Erlang</a>, <a href="http://akka.io">Akka</a>).</p>

<p>Many have written [<a href="#references">1</a>, <a href="#references">2</a>, <a href="#references">3</a>] on functional programming and the advantages of designing programs that emphasize pure functions and immutable values, and that minimize or eliminate, wherever possible, mutable state. Of course, it's not always possible to completely eliminate the need for mutable state, and that's where Clojure's precise <a href="http://clojure.org/state">model of time, identity, and state</a> becomes powerful.</p>

<p>Likewise, when designing distributed applications, it is desirable to create components that are loosely coupled and that communicate with each other asynchronously, but this too is also not always possible. There are times when you need coordinated access to state across systems in a distributed application, and this is where Avout comes in.</p>

<p>Below is the Avout equivalent of *Hello World*.</p>

<pre><code>(use 'avout.core)
(def client (connect "127.0.0.1"))

(def r0 (zk-ref client "/r0" 0))
(def r1 (zk-ref client "/r1" []))

(dosync!! client
  (alter!! r0 inc)
  (alter!! r1 conj @r0))
</code></pre>

<p>Start by creating a ZooKeeper client with the <strong>connect</strong> function, then create two ZooKeeper-backed distributed Refs using the <strong>zk-ref</strong> function. Finally, perform a <strong>dosync!!</strong> transaction that updates both Refs with <strong>alter!!</strong>. Using Avout isn't much different than using Clojure's in-memory Atoms and Refs.</p>

<p><em>Avout</em> Atoms and Refs implement Clojure's IRef interface, and therefore support functions that operate on IRefs, including: deref (and its reader-macro, @), set-validator!, add-watch, and remove-watch.</p>

<p><em>Avout</em> also provides <strong>"double-bang"</strong> versions of the remaining core Atom and Ref functions (<a href="http://clojuredocs.org/clojure_core/clojure.core/reset!">reset!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/swap!">swap!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/dosync">dosync</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/ref-set">ref-set</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/alter">alter</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/commute">commute</a>) for use with distributed Atoms and Refs, <strong>reset!!, swap!!, dosync!!, ref-set!!, alter!!, commute!!</strong>.</p>

<p><em>Note: Avout Refs cannot participate in in-memory dosync transactions, but Avout's **local-ref** provides the equivalent of an in-memory Ref that can participate in dosync!! transactions with distributed Refs.</em></p>

<p>To learn more about Avout and distributed-state in Clojure, visit <a href="http://avout.io">avout.io</a></p>

<h3>More on Avout</h3>
<ul>
<li><a href="http://avout.io/#background">Background</a></li>
<li><a href="http://avout.io/#tutorial">Getting Started</a></li>
<li><a href="http://github.com/liebke/avout">Source Code</a></li>
</ul>

<h3>Roadmap</h3>
<ol>
<li>Provide Avout Java API</li>
<li>Optimize commute!! implementation, currently commute!! just calls alter!!</li>
<li>Implement distributed agents</li>
<li>Experiment with other back-end state-stores, e.g. <a href="http://www.terracotta.org/">Terracotta</a>, <a href="http://java.sun.com/developer/technicalArticles/tools/JavaSpaces/">JavaSpaces</a></li>
<li>Abstract out ZooKeeper functionality and implement a version of Avout without dependencies or one with other dependencies, e.g. <a href="http://www.jgroups.org/">JGroups</a></li>
</ol>


<a name="references" />
<h3>References</h3>
<ol>
<li><a href="http://web.mac.com/ben_moseley/frp/paper-v1_01.pdf">Out of the Tar Pit</a></li>
<li><a href="http://clojure.org/state">Clojure State</a></li>
<li><a href="http://www.eecs.usma.edu/webs/people/okasaki/pubs.html">Okasaki Publications</a></li>
</ol>
