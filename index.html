<head>
<title>Avout: Distributed State in Clojure</title>

<style type="text/css">

  body {font-family: Garamond, Bodoni, "Times New Roman"; background-color: #333333; padding-top: 0px; font-size: 1.2em; color: #333333; }
  h1 { font-family: Garamond, Georgia, serif; color: #666666; }
  h2 { font-family: Helvetica, Gill, sans-serif; color: #666666; }
  h3, h4 { color: #444444; }
  li {padding-left: 25px; padding-right: 25px; padding-top: 5px; }
  .code-ref { background-color: #F8F8F8; color: #003399; font-style:italic; padding-left: 5px; padding-right: 5px; font-size: 0.9em; }
  .code-sig { background-color: #DDDDDD; color: #003399; font-family: "Courier New", Courier; padding-left: 5px; }
  .code-listing { background-color: #FFFFFF; color: #444444; border: #EEEEEE 1px solid;  padding-bottom: 1px; padding-left: 5px; border-bottom: #DDDDDD 1px solid; border-right: #DDDDDD 1px solid; font-size: 1em }
  .quote { background-color: #F8F8F8; color: #555555; font-style:italic; padding-left: 25px; padding-right: 25px; width: 500px; margin: 15px; }
code { color: #555555; }
  .content { background-color: #ffffff; width: 750px; margin: 0px auto; }
  .content-frame { padding-top: 20px; padding-bottom: 5px; background: #ffffff; width: 900px; margin: 0px auto; }
  p { text-align: justify; }
  .box { background-color: #DDDDDD; color: #333333; padding-left:
  15px; padding-top: 15px; padding-bottom: 15px;  border: #CCCCCC 1px
  solid; border-bottom: #CCCCCC 1px solid; border-right: #CCCCCC 1px
  solid; font-size: 0.95em; font-family: Helvetica, Gill, sans-serif; }
  .box li { padding: 2px; }
  .box ul { margin-top: 5px; margin-bottom: 2px; }
  .footnote { font-style: italic; color:#777777; font-size: 0.9em; padding-left: 5px;
  padding-right: 25px; padding-bottom: 10px; }

  strike, s { text-decoration: line-through; color: red; font-weight: bold; }
  .insert { font-weight: bold; font-style: italic; color:#33a933;}

  .menu { margin-bottom: 5px; margin-top: 5px; padding-left:0px; padding-right:0px; }
  .menu-item { margin-left: 0px; color: #ffffff; font-family: Helvetica, Gill, sans-serif; color: #000066; font-size: 0.9em; display: inline; }
  a.menu { color: #999999; text-decoration: none; }
</style>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12283660-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>

<div align="center" style="padding-bottom: 0px">
<ul class="menu">
<li class="menu-item"><a class="menu" href="#overview">Overview</a></li>
<li class="menu-item"><a class="menu" href="#tutorial">Tutorial</a></li>
<li class="menu-item"><a class="menu" href="#avout-atoms-refs">Distributed Atoms & Refs</a></li>
<li class="menu-item"><a class="menu" href="#locks">Distributed Locks</a></li>
<li class="menu-item"><a class="menu" href="https://github.com/liebke/avout">Source Code</a></li>
</ul>
</div>

<div class="content-frame">

<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js" type="text/javascript"></script>

<link href="css/shClojureExtra.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/shBrushClojure.js"></script>
 

<!-- Finally, to actually run the highlighter, you need to include this JS on your page -->
<script type="text/javascript">
     SyntaxHighlighter.all()
</script>


<div class="content">


<p><center><img width="550" src="images/avout-logo.png" /></center></p>


<a name="overview" />
<h2>Overview</h2>

<p>Much has been written on functional programming and the advantages of designing programs that emphasize pure functions and immutable values, and that minimize or eliminate, wherever possible, mutable state. Of course, it's not always possible to completely eliminate the need for mutable state, and that's where Clojure's precise <a href="http://clojure.org/state">model of time, identity, and state</a> becomes powerful.</p>

<p>Likewise, when designing distributed applications, it is desirable to create components that are loosely coupled and that communicate with each other asynchronously, but this too is also not always possible. There are times when you need coordinated access to state across systems in a distributed application, and this is where <a href="https://github.com/liebke/avout">Avout</a> comes in.</p>

<p><em>Avout</em> provides distributed-state, Clojure-style by extending Clojure's syntax and semantics for managing in-memory state to heterogeneous types of state that span multiple processes and/or systems by providing distributed and extendable versions of Clojure's <a href="http://clojure.org/atoms">Atom</a> and <a href="http://clojure.org/refs">Ref</a>.</p>

<p><em>Avout</em> uses <a href="http://zookeeper.apache.org">ZooKeeper</a> and <a href="https://github.com/liebke/zookeeper-clj">zookeeper-clj</a> to coordinate state change, and also includes distributed implementations of <a href="http://download.oracle.com/javase/1,5,0/docs/api/java/util/concurrent/locks/Lock.html"><em>java.util.concurrent.lock.Lock</em></a> and <a href="http://download.oracle.com/javase/1,5,0/docs/api/java/util/concurrent/locks/ReadWriteLock.html"><em>java.util.concurrent.lock.ReadWriteLock</em></a>.</p>

<p>Below is some background on Avout's design, if your interests don't tend toward the philosophy of <a href="http://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North Whitehead</a>, you can jump directly to the <a href="#tutorial">tutorial</a>.</p>

<a name="state-in-clojure" />
<h3>Clojure's Philosophy of State</h3>

<!--
<p><center><a href="http://www.flickr.com/photos/paulbarry/2613013337/" title="State - You're Doing It Wrong by Paul Barry, on Flickr"><img width="550" src="http://farm4.staticflickr.com/3229/2613013337_bcc9c7857d.jpg" width="500" height="422" alt="State - You're Doing It Wrong"></a></center></p>
-->

<p>Rich Hickey has spoken eloquently on <a href="http://clojure.org/state">mutable state</a> in his talk <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">"Are We There Yet?"</a>. To summarize, Rich and Alfred North Whitehead don't believe in mutable state, it's an illusion. Rather, there are only successions of causally-linked immutable values, and time is derived from the perception of these successions. Causally-linked means the future is a function of the past; processes apply pure functions to immutable values to derive new immutable values, and we assign identity to these chains of values, and perceive change where there is none.</p>

<p>As Rich has been <a href="http://www.infoq.com/presentations/Simple-Made-Easy">known to do</a>, he has provided precise, if not familiar, definitions to some familiar words that describe this model of identity, time, and mutable state.</p>

<ul>
<li><strong>Value</strong>: an immutable magnitude, quantity, number, or composite of these</li>

<li><strong>Identity</strong>: a putative entity we associate with a series of causally related values (states) over time</li>

<li><strong>State</strong>: value of an identity at a moment in time</li>

<li><strong>Time</strong>: relative before/after ordering of causal values.</li>

</ul>

<p>A consequence of this view is that we perceive only snapshots of an unchanging past, not a ever-changing present, and this is exactly how Clojure models time, identity, and mutable state using Atoms, Refs, and Agents.</p>

<p>Perception is massively parallel and uncoordinated, meaning you don't have to coordinate with others to observe the value of an identity, no locks or synchronized blocks or message queues, just grab the most recent snapshot of the identity's value and go.</p>

<p>Writes, on the other hand, must be coordinated. Since future values are derived by applying functions to an identity's most recent immutable value, writes must be atomic. Two processes that observe the same value for an identity cannot both write new values, one will win and the other will have to read the latest value and try its write again. Below is an illustration of how Clojure's, and Avout's, STM performs updates to a Ref's state with two contending writers.</p>

<p><center><img width="700" src="https://github.com/liebke/avout/raw/master/docs/images/stm.png" /></center></p>

<ol>
<li><em>Thread-1</em> creates a Ref, <strong>r</strong>, at time <strong>t0</strong> with a value of 0</li>

<li><em>Thread-2</em> then derefs <strong>r</strong> and oberves the latest value 0 from <strong>t0</strong>.</li>

<li><em>Thread-1</em> then begins a transaction at <strong>t1</strong>, the value of <strong>r</strong> is still 0. </li>

<li><em>Thread-2</em> starts begins its own transaction at <strong>t2</strong>, the value of <strong>r</strong> is also still 0.</li>

<li><em>Thread-1</em> begins committing at <strong>t3</strong>, updating <strong>r</strong>'s <strong>t0</strong> value with the <em>inc</em> function.</li>

<li><em>Thread-2</em> attempts to commit but fails because <em>Thread-1</em> beat it to the commit, so it starts over.</li>

<li>While <em>Thread-2</em> is running the transaction again, <em>Thread-1</em> starts a new transaction, but only observes the value of <strong>r</strong> in it, so it doesn't interfere with <em>Thread-2</em>'s commit. Note that observing a Ref's value outside of a transaction doesn't move time forward, but that observing it inside of transaction, even if you don't change it does.</li>

</ol>

<h3>Transactions</h3>

<p><strong>TODO</strong></p>

<p><center><img width="700" src="https://github.com/liebke/avout/raw/master/docs/images/ref-over-time.png" /></center></p>


<a name="avout-atoms-refs" />
<h2>Avout Distributed Atoms and Refs</h2>

<p><em>Avout</em> Atoms and Refs are <strong>ACI(D)</strong>, providing the same promises of <em>atomicity</em>, <em>consistency</em>, and <em>isolation</em> as Clojure's in-memory versions, and optionally providing <em>durability</em>, depending on the type of Avout Atom or Ref used.</p>

<p><em>Avout</em> Atoms and Refs use <a href="http://zookeeper.apache.org">Apache ZooKeeper</a> to coordinate state change, but not necessarily to hold state. Out of the box, Avout contains an Atom, <em>zk-atom</em>, that does also use ZooKeeper data fields to store its state, and two types of Refs, <em>zk-ref</em>, also backed by ZooKeeper data fields, and <em>local-ref</em>, that is in fact not distributed but provides a mechanism for local Refs to participate in transactions with distributed Refs.</p>

<p><strong>Extendable</strong></p>

<p><em>Avout</em> lets you create new types of distributed Atoms and Refs using the <strong>avout.state.StateContainer</strong> and <strong>avout.state.VersionedStateContainer</strong> protocols, respectively; examples of which are the <strong>MongoDB</strong>-backed <em>mongo-atom</em> and <em>mongo-ref</em>, which can be found in the plugins directory.</p>

<p><strong>Caching</strong></p>

<p><em>Avout</em> provides <strong>caching</strong>, so that multiple derefs of the same Atom/Ref will not need to hit either ZooKeeper nor the back-end state-store until the cache has been invalidated by a local or remote update to the Atom or Ref.</p>

<p><strong>Implements IRef</strong></p>

<p><em>Avout</em> Atoms and Refs implement Clojure's IRef interface, and therefore support functions that operate on IRefs, including: deref (and its reader-macro, @), set-validator!, add-watch, remove-watch.</p>

<p><em>Avout</em> provides "double-bang" versions of the remaining core Atom and Ref functions (<a href="http://clojuredocs.org/clojure_core/clojure.core/reset!">reset!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/swap!">swap!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/dosync">dosync</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/ref-set">ref-set</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/alter">alter</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/commute">commute</a>) for use with distributed Atoms and Refs: <strong>reset!!, swap!!, dosync!!, ref-set!!, alter!!, commute!!</strong>.</p>

<h3>zk-atom and zk-ref</h3>

<p>Both zk-atoms and zk-refs store their state in a ZooKeeper data field as a byte array; deserialization/serialization is performed using Clojure's Reader/Printer (read-str/pr-str). ZooKeeper limits the size of data stored in data fields to 1 megabyte. Because Clojure's printer/reader is used for serialization, only appropriate Clojure data structures can be used as values. However, the ability to implement other back-ends with different serializations schemes is a primary goal of Avout.</p>

<h3>local-ref</h3>

<p>The local-ref stores its state in an in-memory Clojure Atom. Because its state is not network accessible, it can only be access from a single JVM, just like in-memory Refs, but unlike in-memory Refs it can participate in transactions with distributed Refs. This provides two benefits, 1) it provides a mechanism for keeping a value that only needs to be available locally in sync with distributed state using dosync!!, 2) since no serialization/deserialization is performed, arbitrary values can be used, including Java objects.</p>

<h3>mongo-atom and mongo-ref</h3>

<p>In the plugins directory there is a Leiningen project called mongo-avout, which contains an implementation of a MongoDB-backed Atom, mongo-atom, and Ref, mongo-ref. Both support values consisting of any Clojure data structure supported in MongoDB with the <a href="https://github.com/aboekhoff/congomongo">Congomongo Library</a>.</p>

<a name="extending-avout" />

<h3>Extending Avout Atoms and Refs</h3>

<p>The above three types of Atoms and Refs provide examples for implementing other types that use different back-end state-stores and serialization methods. State-stores may, or may not, provide durability. For instance, zk-atom, zk-ref, mongo-atom, and mongo-ref provide durability promises in addition to atomicity, consistency, and isolation, but local-ref does not. Other durable (e.g. (No)SQL databases, RESTful services) or non-durable (e.g. <a href="http://www.terracotta.org/">Terracotta</a>, RESTful services) can be used as the basis of new types of Atoms and Refs.</p>

<p>New types of Atoms are created by implementing the <strong>avout.state.StateContainer</strong> protocol.</p>

<pre class="brush: clojure">
(defprotocol StateContainer
  (initStateContainer [this])
  (destroyStateContainer [this])
  (getState [this])
  (setState [this value]))

</pre>


<p>Once you have implemented a <em>StateContainer</em>, create a distributed Atom by passing it to the <strong>avout.atoms.distributed-atom</strong> function.</p>

<pre class="brush: clojure">
(defn custom-atom [client atom-name] 
  (distributed-atom client atom-name custom-state-container))

</pre>

<p>To create new Ref types, implement <strong>avout.state.VersionedStateContainer</strong>.</p>

<pre class="brush: clojure">
(defprotocol VersionedStateContainer
  (initVersionedStateContainer [this])
  (destroyVersionedStateContainer [this])
  (getStateAt [this version])
  (setStateAt [this value version])
  (deleteStateAt [this version]))

</pre>


<p>Once you have implemented a <em>VersionedStateContainer</em>, create a distributed Ref by passing it to the <strong>avout.refs.distributed-ref</strong> function.</p>

<pre class="brush: clojure">
(defn custom-ref [client ref-name] 
  (distributed-ref client ref-name custom-versioned-state-container))

</pre>

<a name="tutorial" />
<h2>Tutorial</h2>

<p><em>Avout</em> Atoms and Refs implement Clojure's IRef interface, and therefore support functions that operate on IRefs, including: deref (and its reader-macro, @), set-validator!, add-watch, remove-watch. <em>Avout</em> provides "double-bang" versions of the remaining core Atom and Ref functions (<a href="http://clojuredocs.org/clojure_core/clojure.core/reset!">reset!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/swap!">swap!</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/dosync">dosync</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/ref-set">ref-set</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/alter">alter</a>, <a href="http://clojuredocs.org/clojure_core/clojure.core/commute">commute</a>) for use with distributed Atoms and Refs: <strong>reset!!, swap!!, dosync!!, ref-set!!, alter!!, commute!!</strong>.</p>

<p>Avout is available on Github, <a href="https://github.com/liebke/avout">https://github.com/liebke/avout</a>. To get started, you'll need to <a href="#running-zookeeper">run ZooKeeper</a>, and include Avout as a dependency by adding the following to your project.clj file:</p>

<pre class="brush: clojure">
[avout "0.5.0-SNAPSHOT"]

</pre>

<p>Then load the <a href="https://github.com/liebke/avout/blob/master/src/avout/core.clj">avout.core namespace</a>, and create a ZooKeeper client that will be passed to distributed Refs and Atoms when they are created and to dosync!! transactions when they are performed.</p>

<pre class="brush: clojure">
(use 'avout.core)
(def client (connect "127.0.0.1"))

</pre>

<p>The first time you use avout, you'll need to initialize it.</p>

<pre class="brush: clojure">
(init-stm client)

</pre>

<p>Now create a distributed atom, you'll need to pass the ZooKeeper client, a ZooKeeper compliant name (must start with a slash), and an optional initial-value. Skip the initial value if you want to connect to an existing distributed Atom.</p>

<pre class="brush: clojure">
(def a0 (zk-atom client "/a0" 0))

</pre>


<p>Deref it.</p>

<pre class="brush: clojure">
@a0

</pre>

<p>Then you can use the swap!! and reset!! functions just as you would Clojure's built-in swap! and reset! functions.</p>

<pre class="brush: clojure">
(swap!! a0 inc)

</pre>

Use reset!!

<pre class="brush: clojure">
(reset!! a0 0)

</pre>

<p>Create a distributed Ref backed by ZooKeeper data fields</p>

<pre class="brush: clojure">
(def r0 (zk-ref client "/r0" 0))
(def r1 (zk-ref client "/r1" []))

</pre>

Alter both Refs within a dosync!! block.

<pre class="brush: clojure">
(dosync!! client
  (alter!! r0 inc)
  (alter!! r1 conj @r0))

@r0

@r1

(dosync!! client
  (ref-set!! r0 0)
  (ref-set!! r1 []))

</pre>

<p>Move a member from one group to another, across two different ref types (zk and mongo), transactionally so that the member always exist in one group or the other, but never neither group nor both groups.</p>

<p>Define the two groups as refs (one zk-backed, the other mongodb-backed) that contain a map with one fields :members, which is a set of names (Note: mongo-ref and mongo-atom are part of a seperate project called mongo-avout, which lives in the plugins directory, you will need to install it in order to run the following example).</p>

<pre class="brush: clojure">
(import 'avout.refs.mongo)

(def group1 (zk-ref client "/group1" {:members #{"david"}}))
(def group2 (mongo-ref client "/group2" {:members #{"emma"}}))

(dosync!! client
  (alter!! group1 update-in [:members] disj "david")
  (alter!! group2 update-in [:members] conj "david"))

</pre>


<a name="locks" />
<h2>Avout Distributed Locks</h2>

<p>To get started, you'll need to <a href="#running-zookeeper">run ZooKeeper</a>.</p>

<p>The avout.locks namespace contains an implementation of <a href="http://download.oracle.com/javase/1,5,0/docs/api/java/util/concurrent/locks/Lock.html"><em>java.util.concurrent.lock.Lock</em></a>, called ZKDistributedReentrantLock, and an implementation of <a href="http://download.oracle.com/javase/1,5,0/docs/api/java/util/concurrent/locks/ReadWriteLock.html"><em>java.util.concurrent.lock.ReadWriteLock</em></a>, called ZKDistributedReentrantReadWriteLock.</p>

<p><center><img width="700" src="https://github.com/liebke/avout/raw/master/docs/images/locks.png" /></center></p>

<h3>Examples</h3>

<p>First require avout.zookeeper and avout.locks.</p>

<pre class="brush: clojure">
(require '(zookeeper :as zk))
(use 'avout.locks)

</pre>


<p>Then get a ZooKeeper client.    </p>

<pre class="brush: clojure">
(def client (zk/connect "127.0.0.1"))

</pre>

<p>Then create a ZKDistributedReentrantLock with the distributed-lock function.</p>

<pre class="brush: clojure">
(def lock (distributed-lock client :lock-node "/lock"))

</pre>


<pre class="brush: clojure">
(try (.lock lock)
     ... do something
 (finally (.unlock lock)))

</pre>

<p>The lock method blocks until the lock is obtained. It is standard practice to call lock within a try block with a finally statement that unlocks it.</p>

<p>You can use the with-lock macro, which is equivalent to Clojure's locking macro, but designed to work with java.util.concurrent.locks.Lock instead of the traditional monitor locks.</p>

<pre class="brush: clojure">
(with-lock lock
  ... do something)

</pre>

<p>The tryLock method doesn't block while waiting for a lock, instead it returns a boolean indicating whether the lock was obtained.</p>

<pre class="brush: clojure">
(try (.tryLock lock)
  ... do something
  (finally (.unlock lock)))

</pre>

<p>Or use the when-lock and if-lock macros.</p>

<pre class="brush: clojure">
(when-lock lock
   (... do something)


</pre>

<pre class="brush: clojure">
(if-lock lock
  (... got lock, do something)
  (... didn't get lock do something else))

</pre>

<p>The tryLock method can take a timeout duration and units.</p>

<pre class="brush: clojure">
(try (.tryLock lock 10 java.util.concurrent.TimeUnit/MILLISECONDS)
  ... do something
  (finally (.unlock lock)))

</pre>

<p>The macros when-lock-with-timeout and if-lock-with-timeout are also available.</p>

<pre class="brush: clojure">
(when-lock-with-timeout lock 10 java.util.concurrent.TimeUnit/MILLISECONDS
   (... do something)

</pre>

<pre class="brush: clojure">
(if-lock-with-timeout lock 10 java.util.concurrent.TimeUnit/MILLISECONDS
  (... got lock, do something)
  (... didn't get lock do something else))

</pre>


<a name="running-zookeeper"></a>

<h2>Running ZooKeeper</h2>

<p>Download Apache ZooKeeper from <a href="http://zookeeper.apache.org/releases.html">http://zookeeper.apache.org/releases.html</a>.</p>

<p>Unpack to $ZOOKEEPER_HOME (wherever you would like that to be).</p>

<p>Here's an example conf file for a standalone instance, by default ZooKeeper will look for it in $ZOOKEEPER_HOME/conf/zoo.cfg</p>

<pre class="brush: shell">
# The number of milliseconds of each tick
tickTime=2000

</pre>

<pre class="brush: shell">
# the directory where the snapshot is stored.
dataDir=/var/zookeeper

# the port at which the clients will connect
clientPort=2181

</pre>

<p>Ensure that the dataDir exists and is writable.</p>

<p>After creating and customizing the conf file, start ZooKeeper</p>

<pre class="brush: shell">
$ZOOKEEPER_HOME/bin/zkServer.sh start

</pre>


<a name="contributing" />
<h2>Contributing</h2>

<p>Although Avout is not part of Clojure-Contrib, it follows the same guidelines for contributing, which includes signing a <a href="http://clojure.org/contributing">Clojure Contributor Agreement</a> (CA) before contributions can be accepted.</p>


<h2>License</h2>

<p>Avout is distributed under the Eclipse Public License, the same as Clojure.</p>


<a name="references" />
<h2>References</h2>

<ul>
<li><a href="https://github.com/liebke/avout">Avout on Github</a></li>

<li><a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">Are We There Yet?</a></li>

<li><a href="http://clojure.org/state">Clojure State</a></li>

<li><a href="http://clojure.org/refs">Clojure Refs and Transactions</a></li>

<li><a href="http://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a></li>

<li><a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion Concurrency Control</a></li>

<li><a href="http://en.wikipedia.org/wiki/Snapshot_isolation">Snapshot Isolation</a></li>

<li><a href="http://zookeeper.apache.org/">ZooKeeper Website</a></li>

<li><a href="http://www.usenix.org/event/atc10/tech/full_papers/Hunt.pdf">ZooKeeper: Wait-free coordination for Internet-scale systems</a></li>

<li><a href="http://zookeeper.apache.org/doc/trunk/recipes.html">ZooKeeper Recipes and Solutions</a></li>

</ul>



<p style="margin-top: 60px">
<center>
<a href="http://thinkrelevance.com"><img src="http://thinkrelevance.com/images/logo.png" width="100px" style="padding-right: 50px" /></a>
<a href="http://clojure.com"><img src="http://clojure.com/stylesheets/images/logo.png" /></a>
</center>
</p>



<p style="margin-top: 10px; padding-bottom: 5px">
<center><em>Copyright &#169; 2011 David Edgar Liebke and Relevance, Inc</em></center>
</p>

</div>
</div>

<center>
<a href="#"><img src="images/avout-icon-dark.png" width="50" style="margin-top: 20px; padding-bottom: 5px" /></a>
</center>


</body>
